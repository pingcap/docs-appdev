---
title: TiDB 数据库开发规范 - 分页的最佳实践
summary: 介绍分页 SQL 的较好的写法。
---

# 分页的最佳实践

## 1. 分页查询的基本原则

分页查询语句全部都需要带有排序条件，除非业务方明确要求不要使用任何排序来随机展示数据。

详细例子如下：

- 常规分页语句写法（start：起始记录数，page_offset：每页记录数）：

  ```sql
  select * from table_a t order by gmt_modified desc limit start，page_offset;
  ```

- 多表 Join 的分页语句，如果过滤条件在某一张表上，通过子查询过滤数据后分页，再 Join： 

    低效的写法：

    ```sql
    select * from table_a t order by gmt_modified desc limit start，page_offset;
    
    select a.column_a，a.column_b .. . b.column_a，b.column_b .. .  
    from table_t a，table_b b  
    where a.xxx.. .  
    and a.column_c = b.column_d  
    order by a.yyy
    limit start，page_offset;
    ```

    高效的写法： 

    ```sql
    select a.column_a，a.column_b .. . b.column_a，b.column_b .. . 
    from
    (select t.column_a，t.column_b .. .
    from table_t t
    where t.xxx.. .
    order by t.yyy 
    limit start，page_offerset) a,
    table_b b
    where a.column_c = b.column_d;
    
    select * from t limit 10000,10;
    select * from t order by c limit 10000,10;
    ```

## 2. 单字段主键表的分页批处理

常规的分页更新 SQL 一般使用主键或者唯一索引进行排序，再配合 MySQL limit 语法中非常好用的 offset 功能按固定行数拆分页面，然后把页面包装进独立的事务中，从而实现灵活的分页更新。

但是，劣势也很明显：由于需要对主键或者唯一索引进行排序，越靠后的页面参与排序的行数就会越多，尤其当批量处理涉及的数据体量较大时，可能会占用过多计算资源。

首先将数据按照主键排序，然后调用窗口函数 `row_number()` 为每一行数据生成行号，接着调用聚合函数按照设置好的页面大小对行号进行分组，最终计算出每页的最小值和最大值。

```sql
MySQL [demo]> select min(t.serialno) as start_key, max(t.serialno) as end_key, count(*) as page_size from ( select *, row_number () over (order by serialno) as row_num from tmp_loan ) t group by floor((t.row_num - 1) / 50000) order by start_key;
+-----------+-----------+-----------+
| start_key | end_key   | page_size |
+-----------+-----------+-----------+
| 200000000 | 200050001 |     50000 |
| 200050002 | 200100007 |     50000 |
| 200100008 | 200150008 |     50000 |
| 200150009 | 200200013 |     50000 |
| 200200014 | 200250017 |     50000 |
| ......... | ......... | ......... |

| 201900019 | 201950018 |     50000 |
| 201950019 | 201999003 |     48985 |
+-----------+-----------+-----------+
40 rows in set (1.51 sec)
```

接下来，只需要使用 `serialno between start_key and end_key` 查询每个分片的数据即可。如果修改数据时，也可以借助上面计算好的分片信息，实现高效数据更新。

改进方案由于规避了频繁的数据排序操作造成的性能损耗，显著改善了批量处理的效率。

## 3. 复合主键表的分页批处理

对于非索引组织表，可以使用隐藏字段 `_tidb_rowid` 做分页使用。

对于索引组织表，可以用如下方式进行分页计算：

制作元信息表

```sql
mysql> SELECT floor(( t1.row_num - 1 )/ 600000 )+1 rn, min(mvalue),max(mvalue),count(*) FROM (SELECT concat( '(''', customer_id, ''',''', customer_idno, ''')' ) AS mvalue, row_number() over ( ORDER BY customer_id, customer_idno ) AS row_num FROM findpt.customer) t1  GROUP BY floor(( t1.row_num - 1 )/ 600000 )  ORDER BY rn;
+----+--------------------------------------+--------------------------------------+----------+
| rn | min(mvalue)                          | max(mvalue)                          | count(*) |
+----+--------------------------------------+--------------------------------------+----------+
|  1 | ('10000000001','351421198512031871') | ('10000600000','541420198607276566') |   600000 |
|  2 | ('10000600001','410727197307043818') | ('10001200000','221518199305165132') |   600000 |
|  3 | ('10001200001','521527198406224414') | ('10001800000','320209197609305969') |   600000 |
|  4 | ('10001800001','220304197912193073') | ('10002400000','230504197308067651') |   600000 |
|  5 | ('10002400001','121711197208214015') | ('10003000000','430112199003258074') |   600000 |
|  6 | ('10003000001','330609198706142725') | ('10003600000','520519197407128506') |   600000 |
|  7 | ('10003600001','621108199508175476') | ('10004200000','631319197203254252') |   600000 |
|  8 | ('10004200001','350406198608214809') | ('10004800000','500827199406068657') |   600000 |
|  9 | ('10004800001','450311198612295355') | ('10005400000','430713199601229738') |   600000 |
| 10 | ('10005400001','640608199311094703') | ('10006000000','131222199007068025') |   600000 |
| 11 | ('10006000001','110724197808158121') | ('10006600000','410909199902088607') |   600000 |
| 12 | ('10006600001','371802199909286692') | ('10007200000','331616199104157617') |   600000 |
| 13 | ('10007200001','631618198707015770') | ('10007800000','311424198409271703') |   600000 |
| 14 | ('10007800001','450212199805062337') | ('10008400000','141520197703176129') |   600000 |
| 15 | ('10008400001','130920197811106553') | ('10009000000','640206197509055077') |   600000 |
| 16 | ('10009000001','151822197801136758') | ('10009600000','810620197505228665') |   600000 |
| 17 | ('10009600001','230109198906203721') | ('10010000000','340408198312036321') |   400000 |
+----+--------------------------------------+--------------------------------------+----------+
17 rows in set (26.42 sec)

```

批量处理 SQL 案例

```sql
delete from customer where  (customer_id, customer_idno) >= ('10000000001','351421198512031871') and  (customer_id, customer_idno) <= ('10000600000','541420198607276566') order by customer_id,customer_idno;
```
